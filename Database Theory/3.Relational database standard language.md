# 一、SQL概述

## 1、SQL的特点

* 综合统一
* 高度非过程化
* 面向集合的操作方式
* 以同一种语法结构提供两种使用方法
* 语言简洁，易学易用

## 2、综合统一(操纵三级模式)

![](img\操纵三级模式.png)

外模式-视图(view)

模式-基本表(table)

内模式-存储文件(索引)

元组-行(row)

属性-列(column)

基本表是独立存在的表，在 SQL 中一个关系就对应一个表。**一些基本表对应一个存储文件**，一个表可以带若干索引，索引也存放在存储文件中。

**存储文件的逻辑结构组成了关系数据库的内模式**。存储文件的物理文件结构是任意的。

**视图是从基本表或其他视图中导出的表，本身不独立存储在数据库中**，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。 用 SQL 语言对视图和基本表进行查询。在用户眼中，视图和基本表都是关系，而存储文件对用户是透明的。

## 3、SQL语言的动词

| SQL功能  |          动词          |
| :------: | :--------------------: |
| 数据定义 |  CREATE, DROP, ALTER   |
| 数据查询 |         SELECT         |
| 数据操纵 | INSERT, UPDATE, DELETE |
| 数据控制 |     GRANT, REVOKE      |

## 4、SQL环境

**SQL模式(schema)是基本表的集合**。允许在不同的SQL中出现同名的基表名或视图名。

目录是SQL环境中所有模式的集合。

定位基表的方式：**<目录名>.<模式名>.<表名>**

SQL环境要设置默认的目录和模式，以及用户的身份。



**存储过程**是存储在 SQL 服务器上的预编译好的一组为了完成特定功能的 SQL 语句集。通过指定存储过程的名字并给出参数来执行它。

* 系统存储过程：由系统自动创建，完成的功能主要是从系统表中获取信息。
* 用户定义的存储过程：由用户为完成某一特定功能而编写的存储过程。

# 二、学生-课程数据库

该数据库主要由三个表组成：

学生表	Student(Sno, Sname, Ssex, Sage, Sdept)

课程表	Course(Cno, Cname, Cpno, Ccredit)

学生选课表	SC(Sno, Cno, Grade)



## 学生表

| 学号Sno | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
| ------- | --------- | -------- | -------- | ----------- |
| 95001   | 李勇      | 男       | 20       | CS          |
| 95002   | 刘晨      | 女       | 19       | IS          |
| 95003   | 王敏      | 女       | 18       | BME         |
| 95004   | 张立      | 男       | 19       | IS          |

## 课程表

| 课程号Cno | 课程名Cname | 先行课Cpno | 学分Ccredit |
| --------- | ----------- | ---------- | ----------- |
| 1         | 数据库      | 5          | 4           |
| 2         | 数学        |            | 2           |
| 3         | 信息系统    | 1          | 4           |
| 4         | 操作系统    | 6          | 3           |
| 5         | 数据结构    | 7          | 4           |
| 6         | 数据处理    |            | 2           |
| 7         | C语言       | 6          | 4           |

## 学生课程表

| 学号Sno | 课程号Cno | 成绩Grade |
| ------- | --------- | --------- |
| 95001   | 1         | 92        |
| 95001   | 2         | 85        |
| 95001   | 3         | 88        |
| 95002   | 2         | 90        |
| 95002   | 3         | 80        |

# 三、数据定义

SQL的数据定义语句

| 操作对象 |     创建     |    删除    |    修改     |
| :------: | :----------: | :--------: | :---------: |
|    表    | CREATE TABLE | DROP TABLE | ALTER TABLE |
|   视图   | CREATE VIEW  | DROP VIEW  |             |
|   索引   | CREATE INDEX | DROP INDEX |             |



注意<>只是一种标注的方式，在具体的语句中，并不需要用到<>

## 1、模式的定义与删除

### a、定义模式

CREATE SCHEMA <模式名> **AUTHORIZATION <用户名>**

注意

* 如果没有指定模式名，模式就隐含为用户名
* 创建模式，需要用户**具有DBA权限**或者获得了DBA授予的CREATE SCHEMA权限

~~~mysql
例子
CREATE SCHEMA "S-T" AUTHORIZATION WANG;
表示为用户WANG创建了一个S-T模式
~~~

### b、删除模式

DROP SCHEMA <模式名> **<CASCADE|RESTRICT>**;

注意

* CASCADE和RESTRICT两者必选其中之一
* CASCADE(级联)表示**在删除模式同时把该模式中所有的数据库对象全部一起删除**；RESTRICT(限制)表示若该模式下已定义了下属的数据库对象，则**拒绝删除**

## 2、基本表的定义、删除与修改

### a、定义基本表

CREATE TABLE <表名>（ < 列名 > < 数据类型 >[ < 列级完整性约束条件 > ] [ ， < 列名 > < 数据类型 >[ < 列级完整性约束条件 >] ] … [ ， < 表级完整性约束条件 > ] ）；

[]中的内容表示可有可无。

<表名>表示要定义的基本表的名字；

<列名>表示组成该表的各个属性列；

<列级完整性约束条件>涉及相应属性列完整性约束条件

<表级完整性约束条件>涉及一个或多个属性列完整性约束条件

**常用的完整性约束**

* 主码约束 PRIMARY KEY
* 唯一性约束 UNIQUE
* 非空值约束 NOT NULL
* 参照完整性约束



~~~ mysql
例1、建立一个“学生”表 Student ，它由学号 Sno 、姓名 Sname 、性别 Ssex 、年龄 Sage 、所在系 Sdept 五个属性组成。其中学号是主键，并且姓名取值也唯一.

CREATE TABLE Student 
(Sno CHAR(5) primary key, 
Sname CHAR(8) UNIQUE, 
Ssex CHAR(2), 
Sage INT, 
Sdept CHAR(10));

例2、建立一个“学生选课”表 SC ，它由学号Sno 、课程号 Cno ，修课成绩 Grade 组成，其中 (Sno, Cno) 为主码。

主要是Sno，Cno联合作主码
CREATE TABLE SC (
 Sno CHAR(5) ,
 Cno CHAR(3) , 
 Grade int,
 Primary key (Sno, Cno));
 
~~~

对于完整性约束的理解

完整性约束条件**涉及到该表的多个属性列**，则必须**定义在表级上**，否则既可定义在列级，也可以定义在表级。

~~~mysql
Student表
主码： sno 姓名：非空 性别：男、女两值

Course表
主码： cno 课程名：非空 外码： pcno

SC表
主码： (sno,cno) 成绩： 0—100 外码： sno, cno
~~~

答案

~~~mysql
CREATE TABLE Student
 sno CHAR (5),
 sname CHAR (8) NOT NULL,	#列级完整性约束
 sex CHAR (2),
 age SMALLINT,
 dept CHAR (20),
 PRIMARY KEY(sno),	#实体完整性约束
 CHECK sex IN (’男‘ , ’女‘)	#用户自定义的完整性
 );
 
 CREATE TABLE Course
(cno CHAR (4),
 cname CHAR (10) NOT NULL,
 pcno CHAR (4),
 credit SMALLINT,
 PRIMARY KEY (cno),
 FOREIGN KEY (pcno) REFERENCES Course(cno)	#参照完整性约束
);

CREATE TABLE SC
(sno CHAR (5),
 cno CHAR (4) ,
 grade SMALLINT,
 PRIMARY KEY (sno,cno),
 FOREIGN KEY (sno) REFERENCES Student(sno),
 FOREIGN KEY (cno) REFERENCES Course(cno),
 CHECK ((grade IS NULL) OR 
 (grade BETWEEN 0 AND 100))	#用户自定义的完整性
);
~~~

**外码的表示**: FOREIGN KEY (列名) REFERENCES 表名(列名)

### b、修改基本表

ALTER TABLE < 表名 > [ ADD < 新列名 > < 数据类型 > [ 完整性约束 ] ] [ DROP < 完整性约束名 > ] [ALTER COLUMN < 列名 > < 数据类型 > ] [DROP COLUMN < 列名 > < 数据类型 > ] ；

ADD是增加新列和新的完整性约束；

DROP是删除指定的完整性约束条件；

ALTER COLUMN子句是用于修改列名和数据类型

补充定义主码和删除主码

* ALTER TABLE < 表名 > ADD PRIMARY KEY (< 列名表 >)
* ALTER TABLE < 表名 > DROP PRIMARY KEY

~~~mysql
例1、向 Student 表增加“入学时间”列，其数据类型为日期型。

ALTER TABLE Student ADD Scome DATETIME;
注意
1、不论基本表中原来是否已有数据，新增加的列一律为空值。
2、修改原有的列定义可能会破坏已有的数据。

例2、将年龄的数据类型改为半字长整数

ALTER TABLE Student MODIFY Sage SMALLINT;

例3、例 删除关于学号必须取唯一值的约束。

ALTER TABLE Student DROP UNIQUE(Sno);

~~~

### c、删除基本表

DROP TABLE < 表名 >; 

注意

基本表定义一旦删除，**表中的数据、在此表上建立的视图、索引、触发器、断言都将自动被删除掉**。 RESTRICT 确保只有不具有相关对象的表才能被撤销。

## 3、B树

B树

![](img\B树.png)

### m 阶 B 树的结构定义

* 每个结点至多有 m 个子结点
* 除根结点和叶结点外，其它每个结点至少有[m/2]个子结点
* 根结点至少有两个子结点
  * 唯一例外的是根结点就是叶结点时没有子结点
  * 此时 B 树只包含一个结点
* 所有的叶结点在同一层
* 有 k 个子结点的非根结点恰好包含 k-1 个关键码

### B树的性质

* 树高平衡，所有叶结点都在同一层
* 关键码没有重复，**父结点中的关键码是其子结点的分界**
* B 树把（值接近）相关记录放在同一个磁盘页中，从而利 用了访问局部性原理
* B 树保证树中至少有一定比例的结点是满的。这样能够改进空间的利用率 ，减少检索和更新操作的磁盘读取数目

### B树的查找

交替的两步过程 

– 1. 把根结点读出来，在根结点所包含的关键码 K1，… ， Kj中查找给定的关键码值，找到则检索成功 

– 2. 否则，确定要查的关键码值是在某个Ki和 Ki+1之间 ，于是取pi所指向的结点继续查找 。如果 pi指向外部空结点，表示检索失败

## 4、索引的建立与删除

CREATE [UN)IQUE] [CLUSTER] INDEX < 索引名 >  ON < 表名 > (< 列名 >< 次序 >[ [ ， < 列名 >< 次序 >]]…) ；

次序：ASC升序，缺省；DESC是降序

UNIQUE: 每一个索引值只对应惟一的数据记录。 

CLUSTER: 建立聚簇索引，即索引项的顺序与表中记录的物理顺序一致

### 索引建立的原则

**值得建索引**：记录有一定规模，而查询只局限于少数记录 。

索引用得上：**索引列在 where 子句中应频繁使用**。先装数据，后建索引：对于大多数基本表，总是有一批初始数据需要装入。该原则是说，建立关系后，先将这些初始数据装入基表，然后再建索引，这样可加快初始数据的录入。如果建表时就建索引，那么在输入初始数据时，每插入一个记录都要维护一次索引。当然，索引早建晚建都是允许的。

~~~mysql
1、为Student表按学号升序建惟一聚簇索引。
2、为SC表按学号升序和课程号降序建惟一索引。

CREATE UNIQUE CLUSTER INDEX Stno ON Student(Sno);
CREATE UNIQUE INDEX Scno ON SC(Sno, Cno DESC);
~~~

### 删除索引

DROP INDEX <索引名>

注意

* 唯一值索引
  * 对于已含重复值的属性列不能建 UNIQUE 索引
  * **对某个列建立 UNIQUE 索引后，插入新记录时 DBMS 会自动检查新记录在该列上是否取了重复值**。这相当于增加了一个 UNIQUE 约束
* 聚簇索引
  * 建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中记录的物理顺序一致

### 聚簇索引

在一个基本表上最多只能建立一个聚簇索引。对于某些类型的查询，可以提高查询的效率。

适用范围

* 很少对基表进行增删操作 
* 很少对其中的变长列进行修改操作

在下列三种情况下，有必要建立簇索引：

1) 查询语句中采用该字段作为排序列 

2) 需要返回局部范围的大量数据 

3) 表格中某字段内容的重复性比较大

~~~
case 1: 对 c1,c2,c3 三列按此顺序添加一个多列索引 ;
case 2: 对 c1,c2,c3 分别建立三个单列索引 ;

问题 1: 按 c1 搜索时，哪种索引效率快 ?
答： case2

问题 2: 按 C2 搜索时，哪种索引效率快 ?
答： case2, 并且， case1 的索引无效

问题 3 ：按 C1,C2,C3 搜索哪种效率快 ?
答： case1

问题 4 ：按 C2,C3,C1 搜索时哪种效率快 ?
答： case2, 因为没有按多列索引的顺序搜索， case1 的索引没有使用到。
~~~

### 聚簇索引与非聚簇索引

当在同一表格中建立簇索引和非簇索引时，先建立簇索引后建非簇索引比较好。

~~~mysql
例1、删除 Student 表的 Stusname 索引。
DROP INDEX Student.Stusname ；
~~~

# 四、数据查询

SELECT [ALL|DISTINCT] < 目标列表达式 > [ ， < 目标列表达式 >] … 

**FROM** < 表名或视图名 > [ ， < 表名或视图名 > ] … 

[ **WHERE** < 条件表达式 > ] 

[ **GROUP BY** < 列名 1> [ HAVING < 条件表达式 > ] ] 

[ **ORDER BY** < 列名 2> [ ASC|DESC ] ] ；

~~~
其中： […] ：表示其中的成分为任选项。
 <…> ：表示其中的成分由用户具体给定。
 | ： 表示其中并列的成分只能择一。
 ALL ：表示保留满足条件的所有元组（缺省）。
 DISTINCT ：表示去掉重复元组。
目标列：可以为属性名、表达式、通配符‘ *’ （表示所有属性列）。
~~~



## 1、单表查询

### a、选择表中的列

~~~mysql
例 查全体学生的姓名及其出生年份

SELECT Sname, 2020-Sage FROM Student; 
SELECT Sname, 2020-Sage AS Birthday FROM Student;	#这里是将Birthday作为别名

例 查全体学生的姓名、出生年份和所有系，要求用小写字母表示所有系名
 
SELECT Sname,
'Year of Birth:'
, 2020-Sage,
LOWER(Sdept) FROM Student;
~~~



### b、选择表中的行

**消除取值重复的行，增加DISTINCT**即可。

**查找满足条件的元组，只需通过WHERE子句**即可。

常见的查询条件

* 比较-比较运算符
* 确定范围-BETWEEN AND, NOT BETWEEN AND
* 确定集合-IN, NOT IN
* 字符匹配-LIKE, NOT LIKE
* 空值-IS NULL, IS NOT NULL
* 多重条件-AND, OR



~~~mysql
例 : 查询选 002 号课程且成绩在 80--90 的学生号。
 
 SELECT sno
 FROM SC
 WHERE sno=‘002’ AND grade BETWEEN 80 AND 90 ;
 
例：查询 BME 、 IS 何计算机学院学生的姓名和性别。

SELECT sname ， sex
 FROM Student
 WHERE dept (NOT) IN ('BME',' IS',' 计算机学院 ')
  
~~~

字符匹配是近似查询，模糊查询的意思

**[NOT] LIKE '<匹配串>'**

含义：是查找指定的属性列值与 < 匹配串 > 相匹配的元组。 

其中匹配串可含： 

* ％：代表任意长度 (可为 0) 的字符串。  
* _ ：代表任意**单个字符**。

~~~mysql
例1、查所有姓刘或姓王的学生姓名、学号和性别。

SELECT sname ， sno ， sex FROM Student WHERE sname LIKE ‘ 刘％’ OR sname LIKE ‘ 王％’ ；
~~~



